<!doctype html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"> <head> <title>STL Tracker Live - live online satellite tracking</title> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <meta name="theme-color" content="#A51818"/> <link rel="shortcut icon" href="favicon.ico"> <link rel="manifest" href="tracker.webmanifest"> <link rel="stylesheet" type="text/css" href="tracker.css"/> <script>
function initMapObserver() {
}
</script> <script async defer type="text/javascript" src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDYBleTtN1Fc3Z-WMGDXzayLIxqxJSoPAY&callback=initMapObserver"></script> <script type="text/javascript" src="./tracker.js"></script> <script id="shader-fs-symbol" type="x-shader/x-fragment">
precision mediump float;
uniform vec4 uColor;
void main(void) {
gl_FragColor = uColor;
}
</script> <script id="shader-vs-symbol" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;
uniform mat4 uTranslateMatrix;
uniform mat4 uScaleMatrix;
void main(void) {
gl_Position = uTranslateMatrix * uScaleMatrix * vec4(aVertexPosition, 1.0);
}
</script> <script id="shader-fs-track-perspective" type="x-shader/x-fragment">
precision mediump float;
uniform vec4 uColor;
void main(void) {
gl_FragColor = uColor;
}
</script> <script id="shader-vs-track-perspective" type="x-shader/x-vertex">
attribute vec4 aVertexPosition;
uniform mat4 uPMatrix;
uniform mat4 uMVMatrix;
void main(void) {
gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition.xyz, 1.0);
}
</script> <script id="shader-vs-track-perspective-ground" type="x-shader/x-vertex">
attribute vec4 aVertexPosition;
uniform mat4 uPMatrix;
uniform mat4 uMVMatrix;
void main(void) {
gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition.xyz / (0.9999 * length(aVertexPosition.xyz)), 1.0);
}
</script> <script id="shader-fs-globe-perspective" type="x-shader/x-fragment">
precision highp float;
const float PI = 3.14159265358979323846264;
const float FOOTPRINTS_ARRAY_NUM_SATELLITES = 1024.0;
const float CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE = 672946987.0 / 255.0;
varying vec2 vTextureCoord;
uniform sampler2D uSamplerDay;
uniform sampler2D uSamplerNight;
uniform sampler2D uSamplerMask;
uniform sampler2D uSamplerBoundaries;
uniform sampler2D uSamplerFootprints;
uniform vec4 uColorSeas;
uniform vec4 uColorLand;
uniform vec4 uColorDay;
uniform vec4 uColorNight;
uniform vec4 uColorLongitudeLatitudeGrid;
uniform vec4 uColorTerminator;
uniform vec4 uColorBoundaries;
uniform float uSolarLongitude;
uniform float uSolarLatitude;
uniform float uLineWidth;
uniform int uNumSatellites;
uniform bool bUseSatelliteImage;
uniform bool bFillLand;
uniform bool bFillSeas;
uniform bool bDisplayDayNight;
uniform bool bDisplayLongitudeLatitudeGrid;
uniform bool bDisplayTerminator;
uniform bool bDisplayBoundaries;
uniform bool bDisplayBoundariesCoastlines;
uniform bool bDisplayBoundariesInternal;
float calculateValue(vec4 value) {
return ( value[0] * 256.0 * 256.0 * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[1] * 256.0 * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[2] * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[3] / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE );
}
float calculateDistance(float lat1, float long1, float lat2, float long2) {
return 2.0 * asin( clamp( sqrt( pow( ( sin( ( lat1 - lat2 ) / 2.0) ), 2.0) + cos( lat1 ) * cos( lat2 ) * pow( ( sin( ( long1 - long2 ) / 2.0) ), 2.0 ) ), -1.0, 1.0 ) );
}
void main(void) {
float distance;
float cosDistance;
float longitudeSatellite;
float latitudeSatellite;
float longitudeTexture = 2.0 * PI * ( vTextureCoord.s - 0.5 );
float latitudeTexture = PI * ( vTextureCoord.t - 0.5 );
float sinLatitudeTexture = sin( PI * ( vTextureCoord.t - 0.5 ) );
float cosLatitudeTexture = cos( PI * ( vTextureCoord.t - 0.5 ) );
float cosAngle;
float angle;
vec4 value;
vec4 footprintColor;
vec4 textureColor;
cosDistance = cos(calculateDistance( latitudeTexture, longitudeTexture, uSolarLatitude, uSolarLongitude ));
if (bUseSatelliteImage) {
if (bDisplayDayNight) {
textureColor = mix( texture2D(uSamplerDay, vTextureCoord), texture2D(uSamplerNight, vTextureCoord), smoothstep(-0.075, 0.075, -cosDistance) );
} else {
textureColor = texture2D(uSamplerDay, vTextureCoord);
}
} else {
if (bDisplayDayNight) {
textureColor = mix( uColorDay, uColorNight, smoothstep(-0.075, 0.075, -cosDistance) );
} else {
textureColor = uColorDay;
}
}
if (bFillLand || bFillSeas) {
float mask = texture2D( uSamplerMask, vTextureCoord ).rgb.r;
if (bFillLand) {
textureColor = mix( textureColor, uColorLand, mask * uColorLand.a );
}
if (bFillSeas) {
textureColor = mix( textureColor, uColorSeas, ( 1.0 - mask ) * uColorSeas.a );
}
}
if ((bDisplayBoundaries && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.r > 0.1) ||
(bDisplayBoundariesCoastlines && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.g > 0.1) ||
(bDisplayBoundariesInternal && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.b > 0.1)) {
textureColor = mix( textureColor, uColorBoundaries, uColorBoundaries.a );   
}
if (bDisplayTerminator && uLineWidth > 0.0) {
if (abs(cosDistance) < uLineWidth * PI) {
textureColor = mix( textureColor, uColorTerminator, uColorTerminator.a );
}
}
if (bDisplayLongitudeLatitudeGrid && uLineWidth > 0.0) {
if (abs(mod(vTextureCoord.s + (uLineWidth / (2.0*cosLatitudeTexture)), 1.0 / 12.0)*cosLatitudeTexture) < uLineWidth || abs(mod(vTextureCoord.t + uLineWidth, 1.0 / 6.0)) < 2.0*uLineWidth) {
textureColor = mix( textureColor, uColorLongitudeLatitudeGrid, uColorLongitudeLatitudeGrid.a );
}
}
for (int satellite = 0; satellite < int(FOOTPRINTS_ARRAY_NUM_SATELLITES); satellite++) { 
if (satellite >= uNumSatellites) {
break;
}
footprintColor = texture2D(uSamplerFootprints, vec2(0.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0));
value = texture2D(uSamplerFootprints, vec2(1.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0));
longitudeSatellite = calculateValue(value);
value = texture2D(uSamplerFootprints, vec2(2.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0));
latitudeSatellite = calculateValue(value) - ( PI / 2.0 );
distance = calculateDistance(latitudeSatellite, longitudeSatellite, latitudeTexture, longitudeTexture);
angle = calculateValue(texture2D(uSamplerFootprints, vec2(3.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0)));
if (angle < PI / 2.0) {
if (distance < angle) {
textureColor = mix( textureColor, footprintColor, footprintColor.a );
}
}
for (int index=0; index < 4; index++) {
angle = calculateValue(texture2D(uSamplerFootprints, vec2((4.5+float(index))/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0)));
if (angle < PI / 2.0) {
if (distance <= angle + ( uLineWidth * PI ) && distance >= angle - ( uLineWidth * PI ) ) {
textureColor = mix( textureColor, footprintColor, 1.0 );
}
}
}
}
gl_FragColor = vec4(textureColor.rgb, 1);
}
</script> <script id="shader-vs-globe-perspective" type="x-shader/x-vertex">
precision highp float;
attribute vec3 aVertexPosition;
attribute vec2 aTextureCoord;
uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
varying vec2 vTextureCoord;
void main(void) {
gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
vTextureCoord = aTextureCoord;
}
</script> <script id="shader-fs-track-projection" type="x-shader/x-fragment">
precision mediump float;
varying float alpha;
uniform vec4 uColor;
void main(void) {
gl_FragColor = vec4(uColor.rgb, 0.5);
if (alpha == 0.0) {
discard;
}
}
</script> <script id="shader-vs-track-cylindrical" type="x-shader/x-vertex">
attribute vec4 aVertexPosition;
attribute vec4 aVertexPositionPrevNext;
varying float alpha;
uniform float uCentralLongitude;
const float PI = 3.14159265358979323846264;
void main(void) {
alpha = 1.0;
gl_Position = vec4( mod( 6.0 + ( atan( -aVertexPosition[2], aVertexPosition[0] ) / PI ) - ( 2.0 * uCentralLongitude ), 2.0) - 1.0, 2.0 * aVertexPosition[3] / PI, -0.01, 1.0);
float positionPrevNextLongitude = mod( 6.0 + ( atan( -aVertexPositionPrevNext[2], aVertexPositionPrevNext[0] ) / PI ) - ( 2.0 * uCentralLongitude ), 2.0) - 1.0;
float positionPrevNextLatitude = 2.0 * aVertexPositionPrevNext[3] / PI;
if (abs(gl_Position[0] - positionPrevNextLongitude) > 1.0) {
float m;
float c;
if (gl_Position[0] > positionPrevNextLongitude) {
m = ( positionPrevNextLatitude - gl_Position[1] ) / ( positionPrevNextLongitude + 2.0 - gl_Position[0] );
c = gl_Position[1] - ( m * gl_Position[0] );
gl_Position[0] = 1.0;
gl_Position[1] = m + c;
} else {
m = ( positionPrevNextLatitude - gl_Position[1] ) / ( positionPrevNextLongitude - 2.0 - gl_Position[0] );
c = gl_Position[1] - ( m * gl_Position[0] );
gl_Position[0] = -1.0;
gl_Position[1] = -m + c;
}
alpha = 0.0;
}
}
</script> <script id="shader-vs-track-elliptical" type="x-shader/x-vertex">
precision highp float;
attribute vec4 aVertexPosition;
attribute vec4 aVertexPositionPrevNext;
varying float alpha;
uniform float uCentralLongitude;
const float PI = 3.14159265358979323846264;
const float DELTA = 0.00005;
vec2 calculatePosition(float longitude, float latitude) {
float dTheta = 2.0 * asin( latitude );
float cosTheta;
if (dTheta < PI - DELTA && dTheta > -PI + DELTA) {
float dThetaOld;
for (int i=0; i < 500; i++) {
dThetaOld = dTheta;
dTheta -= ( dTheta + sin( dTheta ) - PI * sin( 0.5 * latitude * PI ) ) / ( 1.0 + cos( dTheta ) );
if (abs( dTheta - dThetaOld ) < 0.0001) {
break;
}
}
dTheta /= 2.0;
cosTheta = cos( dTheta );
} else {
dTheta /= 2.0;
cosTheta = DELTA;
}
return vec2(longitude * cosTheta, sin( dTheta ));
}
void main(void) {
float longitude = mod( 6.0 + ( atan( -aVertexPosition[2], aVertexPosition[0] ) / PI ) - ( 2.0 * uCentralLongitude ), 2.0) - 1.0;
float longitudePrevNext = mod( 6.0 + ( atan( -aVertexPositionPrevNext[2], aVertexPositionPrevNext[0] ) / PI ) - ( 2.0 * uCentralLongitude ), 2.0) - 1.0;
float latitude = 2.0 * aVertexPosition[3] / PI;
alpha = 1.0;
if (abs(longitude - longitudePrevNext) > 1.0) {
float latitudePrevNext = 2.0 * aVertexPositionPrevNext[3] / PI;
float latitudeCommon;
if (longitude <= -1.0 || longitude >= 1.0) {
latitudeCommon = latitude;
} else if (longitudePrevNext <= -1.0 || longitudePrevNext >= 1.0) {
latitudeCommon = latitudePrevNext;
} else {
float weight = 1.0/(abs(longitude) - 1.0);
float weightPrevNext = 1.0/(abs(longitudePrevNext) - 1.0);
latitudeCommon = (latitude * weight) + (latitudePrevNext * weightPrevNext);
latitudeCommon /= weight + weightPrevNext;
}
if (longitude > longitudePrevNext) {
gl_Position = vec4( calculatePosition(1.0, latitudeCommon), -0.01, 1);
} else {
gl_Position = vec4( calculatePosition(-1.0, latitudeCommon), -0.01, 1);
}
alpha = 0.0;
} else {
gl_Position = vec4( calculatePosition(longitude, latitude), -0.01, 1);
}
}
</script> <script id="shader-vs-track-sinusoidal" type="x-shader/x-vertex">
attribute vec4 aVertexPosition;
attribute vec4 aVertexPositionPrevNext;
varying float alpha;
uniform float uCentralLongitude;
const float PI = 3.14159265358979323846264;
const float DELTA = 0.00005;
vec2 calculatePosition(float longitude, float latitude) {
return vec2(longitude * cos(latitude * PI / 2.0), latitude);
}
void main(void) {
float longitude = mod( 6.0 + ( atan( -aVertexPosition[2], aVertexPosition[0] ) / PI ) - ( 2.0 * uCentralLongitude ), 2.0) - 1.0;
float longitudePrevNext = mod( 6.0 + ( atan( -aVertexPositionPrevNext[2], aVertexPositionPrevNext[0] ) / PI ) - ( 2.0 * uCentralLongitude ), 2.0) - 1.0;
float latitude = 2.0 * aVertexPosition[3] / PI;
alpha = 1.0;
if (abs(longitude - longitudePrevNext) > 1.0) {
float latitudePrevNext = 2.0 * aVertexPositionPrevNext[3] / PI;
float latitudeCommon;
if (longitude <= -1.0 || longitude >= 1.0) {
latitudeCommon = latitude;
} else if (longitudePrevNext <= -1.0 || longitudePrevNext >= 1.0) {
latitudeCommon = latitudePrevNext;
} else {
float weight = 1.0/(abs(longitude) - 1.0);
float weightPrevNext = 1.0/(abs(longitudePrevNext) - 1.0);
latitudeCommon = (latitude * weight) + (latitudePrevNext * weightPrevNext);
latitudeCommon /= weight + weightPrevNext;
}
if (longitude > longitudePrevNext) {
gl_Position = vec4( calculatePosition(1.0, latitudeCommon), -0.01, 1);
} else {
gl_Position = vec4( calculatePosition(-1.0, latitudeCommon), -0.01, 1);
}
alpha = 0.0;
} else {
gl_Position = vec4( calculatePosition(longitude, latitude), -0.01, 1);
}
}
</script> <script id="shader-vs-track-robinson" type="x-shader/x-vertex">
precision highp float;
attribute vec4 aVertexPosition;
attribute vec4 aVertexPositionPrevNext;
varying float alpha;
uniform float uCentralLongitude;
uniform vec3 uRobinsonMap[19];
const float PI = 3.14159265358979323846264;
const int NUM_ROBINSON_MAP_STEPS = 19;
vec2 calculatePosition(float longitude, float latitude) {
float latitudeDegrees = latitude * 90.0;
float x = longitude;
float y = latitude;
int index;
index = int(abs(latitudeDegrees / (90.0 / float(NUM_ROBINSON_MAP_STEPS-1))));
if (index >= NUM_ROBINSON_MAP_STEPS - 2) {
index = NUM_ROBINSON_MAP_STEPS - 2;
}
x = longitude * ( ( ( abs( latitudeDegrees ) - uRobinsonMap[index+0][0] ) * uRobinsonMap[index+1][1] ) +
( ( uRobinsonMap[index+1][0] - abs( latitudeDegrees ) ) * uRobinsonMap[index+0][1] ) ) /
( uRobinsonMap[index+1][0] - uRobinsonMap[index+0][0] );
y = sign( latitude ) * ( ( ( abs( latitudeDegrees ) - uRobinsonMap[index+0][0] ) * uRobinsonMap[index+1][2] ) +
( ( uRobinsonMap[index+1][0] - abs( latitudeDegrees ) ) * uRobinsonMap[index+0][2] ) ) /
( uRobinsonMap[index+1][0] - uRobinsonMap[index+0][0] );
return vec2(x, y);
}
void main(void) {
float longitude = mod( 6.0 + ( atan( -aVertexPosition[2], aVertexPosition[0] ) / PI ) - ( 2.0 * uCentralLongitude ), 2.0) - 1.0;
float longitudePrevNext = mod( 6.0 + ( atan( -aVertexPositionPrevNext[2], aVertexPositionPrevNext[0] ) / PI ) - ( 2.0 * uCentralLongitude ), 2.0) - 1.0;
float latitude = 2.0 * aVertexPosition[3] / PI;
alpha = 1.0;
if (abs(longitude - longitudePrevNext) > 1.0) {
float latitudePrevNext = 2.0 * aVertexPositionPrevNext[3] / PI;
float latitudeCommon;
if (longitude <= -1.0 || longitude >= 1.0) {
latitudeCommon = latitude;
} else if (longitudePrevNext <= -1.0 || longitudePrevNext >= 1.0) {
latitudeCommon = latitudePrevNext;
} else {
float weight = 1.0/(abs(longitude) - 1.0);
float weightPrevNext = 1.0/(abs(longitudePrevNext) - 1.0);
latitudeCommon = (latitude * weight) + (latitudePrevNext * weightPrevNext);
latitudeCommon /= weight + weightPrevNext;
}
if (longitude > longitudePrevNext) {
gl_Position = vec4( calculatePosition(1.0, latitudeCommon), -0.01, 1);
} else {
gl_Position = vec4( calculatePosition(-1.0, latitudeCommon), -0.01, 1);
}
alpha = 0.0;
} else {
gl_Position = vec4( calculatePosition(longitude, latitude), -0.01, 1);
}
}
</script> <script id="shader-fs-globe-cylindrical" type="x-shader/x-fragment">
precision highp float;
const float PI = 3.14159265358979323846264;
const float FOOTPRINTS_ARRAY_NUM_SATELLITES = 1024.0;
const float CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE = 672946987.0 / 255.0;
varying vec2 vTextureCoord;
uniform sampler2D uSamplerDay;
uniform sampler2D uSamplerNight;
uniform sampler2D uSamplerMask;
uniform sampler2D uSamplerBoundaries;
uniform sampler2D uSamplerFootprints;
uniform vec4 uColorSeas;
uniform vec4 uColorLand;
uniform vec4 uColorDay;
uniform vec4 uColorNight;
uniform vec4 uColorLongitudeLatitudeGrid;
uniform vec4 uColorTerminator;
uniform vec4 uColorBoundaries;
uniform float uSolarLongitude;
uniform float uSolarLatitude;
uniform float uLineWidth;
uniform float uLineWidthS;
uniform float uLineWidthT;
uniform int uNumSatellites;
uniform bool bUseSatelliteImage;
uniform bool bFillLand;
uniform bool bFillSeas;
uniform bool bDisplayDayNight;
uniform bool bDisplayLongitudeLatitudeGrid;
uniform bool bDisplayTerminator;
uniform bool bDisplayBoundaries;
uniform bool bDisplayBoundariesCoastlines;
uniform bool bDisplayBoundariesInternal;
float calculateValue(vec4 value) {
return ( value[0] * 256.0 * 256.0 * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[1] * 256.0 * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[2] * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[3] / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE );
}
float calculateDistance(float lat1, float long1, float lat2, float long2) {
return 2.0 * asin( clamp( sqrt( pow( ( sin( ( lat1 - lat2 ) / 2.0) ), 2.0) + cos( lat1 ) * cos( lat2 ) * pow( ( sin( ( long1 - long2 ) / 2.0) ), 2.0 ) ), -1.0, 1.0 ) );
}
void main(void) {
float distance;
float cosDistance;
float longitudeSatellite;
float latitudeSatellite;
float longitudeTexture = 2.0 * PI * ( vTextureCoord.s - 0.5 );
float latitudeTexture = PI * ( vTextureCoord.t - 0.5 );
float cosAngle;
float angle;
vec4 value;
vec4 footprintColor;
vec4 textureColor;
cosDistance = cos(calculateDistance( latitudeTexture, longitudeTexture, uSolarLatitude, uSolarLongitude ));
if (bUseSatelliteImage) {
if (bDisplayDayNight) {
textureColor = mix( texture2D(uSamplerDay, vTextureCoord), texture2D(uSamplerNight, vTextureCoord), smoothstep(-0.075, 0.075, -cosDistance) );
} else {
textureColor = texture2D(uSamplerDay, vTextureCoord);
}
} else {
if (bDisplayDayNight) {
textureColor = mix( uColorDay, uColorNight, smoothstep(-0.075, 0.075, -cosDistance) );
} else {
textureColor = uColorDay;
}
}
if (bFillLand || bFillSeas) {
float mask = texture2D( uSamplerMask, vTextureCoord ).rgb.r;
if (bFillLand) {
textureColor = mix( textureColor, uColorLand, mask * uColorLand.a );
}
if (bFillSeas) {
textureColor = mix( textureColor, uColorSeas, ( 1.0 - mask ) * uColorSeas.a );
}
}
if ((bDisplayBoundaries && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.r > 0.1) ||
(bDisplayBoundariesCoastlines && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.g > 0.1) ||
(bDisplayBoundariesInternal && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.b > 0.1)) {
textureColor = mix( textureColor, uColorBoundaries, uColorBoundaries.a );
}
if (bDisplayTerminator) {
if (abs(cosDistance) < uLineWidth * PI) {
textureColor = mix( textureColor, uColorTerminator, 1.0 );
}
}
if (bDisplayLongitudeLatitudeGrid && (uLineWidthS > 0.0 || uLineWidthT > 0.0)) {
if (abs(mod(vTextureCoord.s + uLineWidthS, 1.0 / 12.0)) < 2.0*uLineWidthS || abs(mod(vTextureCoord.t + uLineWidthT, 1.0 / 6.0)) < 2.0*uLineWidthT) {
textureColor = mix( textureColor, uColorLongitudeLatitudeGrid, uColorLongitudeLatitudeGrid.a );
}
}
for (int satellite = 0; satellite < int(FOOTPRINTS_ARRAY_NUM_SATELLITES); satellite++) {
if (satellite >= uNumSatellites) {
break;
}
footprintColor = texture2D(uSamplerFootprints, vec2(0.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/FOOTPRINTS_ARRAY_NUM_SATELLITES));
value = texture2D(uSamplerFootprints, vec2(1.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/FOOTPRINTS_ARRAY_NUM_SATELLITES));
longitudeSatellite = calculateValue(value);
value = texture2D(uSamplerFootprints, vec2(2.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/FOOTPRINTS_ARRAY_NUM_SATELLITES));
latitudeSatellite = calculateValue(value) - ( PI / 2.0 );
distance = calculateDistance(latitudeSatellite, longitudeSatellite, latitudeTexture, longitudeTexture);
//
// shade the interior of the footprint...
//
angle = calculateValue(texture2D(uSamplerFootprints, vec2(3.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/FOOTPRINTS_ARRAY_NUM_SATELLITES)));
if (angle < PI / 2.0) {
if (distance < angle) {
textureColor = mix( textureColor, footprintColor, footprintColor.a );
}
}
//
// outline the satellite footprint at various angles...
//
for (int index=0; index < 4; index++) {
angle = calculateValue(texture2D(uSamplerFootprints, vec2((4.5+float(index))/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/FOOTPRINTS_ARRAY_NUM_SATELLITES)));
if (angle < PI / 2.0) {
if (distance <= angle + ( uLineWidth * PI ) && distance >= angle - ( uLineWidth * PI ) ) {
textureColor = mix( textureColor, footprintColor, 1.0 );
}
}
}
}
gl_FragColor = vec4(textureColor.rgb, 1);
}
</script> <script id="shader-vs-globe-cylindrical" type="x-shader/x-vertex">
precision highp float;
attribute vec2 aTextureCoord;
varying vec2 vTextureCoord;
uniform float uCentralLongitude;
void main(void) {
gl_Position = vec4( ( aTextureCoord[0] * 2.0 ) - 1.0, ( aTextureCoord[1] * 2.0 ) - 1.0, 0, 1);
vTextureCoord = vec2( aTextureCoord[0] + uCentralLongitude, aTextureCoord[1] );
}
</script> <script id="shader-fs-globe-elliptical" type="x-shader/x-fragment">
precision highp float;
const float PI = 3.14159265358979323846264;
const float FOOTPRINTS_ARRAY_NUM_SATELLITES = 1024.0;
const float CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE = 672946987.0 / 255.0;
varying vec2 vTextureCoord;
uniform sampler2D uSamplerDay;
uniform sampler2D uSamplerNight;
uniform sampler2D uSamplerMask;
uniform sampler2D uSamplerBoundaries;
uniform sampler2D uSamplerFootprints;
uniform vec4 uColorSeas;
uniform vec4 uColorLand;
uniform vec4 uColorDay;
uniform vec4 uColorNight;
uniform vec4 uColorLongitudeLatitudeGrid;
uniform vec4 uColorTerminator;
uniform vec4 uColorBoundaries;
uniform float uSolarLongitude;
uniform float uSolarLatitude;
uniform float uLineWidth;
uniform float uLineWidthS;
uniform float uLineWidthT;
uniform int uNumSatellites;
uniform bool bUseSatelliteImage;
uniform bool bFillLand;
uniform bool bFillSeas;
uniform bool bDisplayDayNight;
uniform bool bDisplayLongitudeLatitudeGrid;
uniform bool bDisplayTerminator;
uniform bool bDisplayBoundaries;
uniform bool bDisplayBoundariesCoastlines;
uniform bool bDisplayBoundariesInternal;
float calculateValue(vec4 value) {
return ( value[0] * 256.0 * 256.0 * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[1] * 256.0 * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[2] * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[3] / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE );
}
float calculateDistance(float lat1, float long1, float lat2, float long2) {
return 2.0 * asin( clamp( sqrt( pow( ( sin( ( lat1 - lat2 ) / 2.0) ), 2.0) + cos( lat1 ) * cos( lat2 ) * pow( ( sin( ( long1 - long2 ) / 2.0) ), 2.0 ) ), -1.0, 1.0 ) );
}
void main(void) {
float distance;
float cosDistance;
float longitudeSatellite;
float latitudeSatellite;
float longitudeTexture = 2.0 * PI * ( vTextureCoord.s - 0.5 );
float latitudeTexture = PI * ( vTextureCoord.t - 0.5 );
float angle;
vec4 value;
vec4 footprintColor;
vec4 textureColor;
cosDistance = cos(calculateDistance( latitudeTexture, longitudeTexture, uSolarLatitude, uSolarLongitude ));
if (bUseSatelliteImage) {
if (bDisplayDayNight) {
textureColor = mix( texture2D(uSamplerDay, vTextureCoord), texture2D(uSamplerNight, vTextureCoord), smoothstep(-0.075, 0.075, -cosDistance) );
} else {
textureColor = texture2D(uSamplerDay, vTextureCoord);
}
} else {
if (bDisplayDayNight) {
textureColor = mix( uColorDay, uColorNight, smoothstep(-0.075, 0.075, -cosDistance) );
} else {
textureColor = uColorDay;
}
}
if (bFillLand || bFillSeas) {
float mask = texture2D( uSamplerMask, vTextureCoord ).rgb.r;
if (bFillLand) {
textureColor = mix( textureColor, uColorLand, mask * uColorLand.a );
}
if (bFillSeas) {
textureColor = mix( textureColor, uColorSeas, ( 1.0 - mask ) * uColorSeas.a );
}
}
if ((bDisplayBoundaries && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.r > 0.1) ||
(bDisplayBoundariesCoastlines && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.g > 0.1) ||
(bDisplayBoundariesInternal && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.b > 0.1)) {
textureColor = mix( textureColor, uColorBoundaries, uColorBoundaries.a );
}
if (bDisplayTerminator) {
if (abs(cosDistance) < uLineWidth * PI) {
textureColor = mix( textureColor, uColorTerminator, uColorTerminator.a );
}
}
if (bDisplayLongitudeLatitudeGrid && (uLineWidthS > 0.0 || uLineWidthT > 0.0)) {
if (abs(mod(vTextureCoord.t + uLineWidthT, 1.0 / 6.0)) < 2.0*uLineWidthT) {
textureColor = mix( textureColor, uColorLongitudeLatitudeGrid, uColorLongitudeLatitudeGrid.a );
} else if (abs(mod(vTextureCoord.s + uLineWidthS, 1.0 / 12.0)) < 3.0*uLineWidthS/abs(cos(PI*0.9*(vTextureCoord.t-0.5)))) {
textureColor = mix( textureColor, uColorLongitudeLatitudeGrid, uColorLongitudeLatitudeGrid.a );
}
}
for (int satellite = 0; satellite < int(FOOTPRINTS_ARRAY_NUM_SATELLITES); satellite++) {
if (satellite >= uNumSatellites) {
break;
}
footprintColor = texture2D(uSamplerFootprints, vec2(0.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/FOOTPRINTS_ARRAY_NUM_SATELLITES));
value = texture2D(uSamplerFootprints, vec2(1.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/FOOTPRINTS_ARRAY_NUM_SATELLITES));
longitudeSatellite = calculateValue(value);
value = texture2D(uSamplerFootprints, vec2(2.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/FOOTPRINTS_ARRAY_NUM_SATELLITES));
latitudeSatellite = calculateValue(value) - ( PI / 2.0 );
distance = calculateDistance(latitudeSatellite, longitudeSatellite, latitudeTexture, longitudeTexture);
//
// shade the interior of the footprint...
//
angle = calculateValue(texture2D(uSamplerFootprints, vec2(3.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/FOOTPRINTS_ARRAY_NUM_SATELLITES)));
if (angle < PI / 2.0) {
if (distance < angle) {
textureColor = mix( textureColor, footprintColor, footprintColor.a );
}
}
//
// outline the satellite footprint at various angles...
//
for (int index=0; index < 4; index++) {
angle = calculateValue(texture2D(uSamplerFootprints, vec2((4.5+float(index))/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/FOOTPRINTS_ARRAY_NUM_SATELLITES)));
if (angle < PI / 2.0) {
if (distance <= angle + ( uLineWidth * PI ) && distance >= angle - ( uLineWidth * PI ) ) {
textureColor = mix( textureColor, footprintColor, 1.0 );
}
}
}
}
gl_FragColor = vec4(textureColor.rgb, 1);
}
</script> <script id="shader-vs-globe-elliptical" type="x-shader/x-vertex">
precision highp float;
attribute vec2 aTextureCoord;
varying vec2 vTextureCoord;
uniform float uCentralLongitude;
const float PI = 3.14159265358979323846264;
const float DELTA = 0.00005;
void main(void) {
float dTheta = 2.0 * asin( (aTextureCoord[1] * 2.0) - 1.0 );
float cosTheta;
if (dTheta < PI - DELTA && dTheta > -PI + DELTA) {
float dThetaOld;
for (int i=0; i < 500; i++) {
dThetaOld = dTheta;
dTheta -= ( dTheta + sin( dTheta ) - PI * sin( (aTextureCoord[1] - 0.5) * PI ) ) / ( 1.0 + cos( dTheta ) );
if (abs( dTheta - dThetaOld ) < 0.0001) {
break;
}
}
dTheta /= 2.0;
cosTheta = cos( dTheta );
} else {
dTheta /= 2.0;
cosTheta = DELTA;
}
gl_Position = vec4( 2.0 * ( (aTextureCoord[0] - 0.5) * cosTheta ), sin( dTheta ), 0, 1);
vTextureCoord = vec2( aTextureCoord[0] + uCentralLongitude, aTextureCoord[1] );
}
</script> <script id="shader-fs-globe-sinusoidal" type="x-shader/x-fragment">
precision highp float;
const float PI = 3.14159265358979323846264;
const float FOOTPRINTS_ARRAY_NUM_SATELLITES = 1024.0;
const float CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE = 672946987.0 / 255.0;
varying vec2 vTextureCoord;
uniform sampler2D uSamplerDay;
uniform sampler2D uSamplerNight;
uniform sampler2D uSamplerMask;
uniform sampler2D uSamplerBoundaries;
uniform sampler2D uSamplerFootprints;
uniform vec4 uColorSeas;
uniform vec4 uColorLand;
uniform vec4 uColorDay;
uniform vec4 uColorNight;
uniform vec4 uColorLongitudeLatitudeGrid;
uniform vec4 uColorTerminator;
uniform vec4 uColorBoundaries;
uniform float uSolarLongitude;
uniform float uSolarLatitude;
uniform float uLineWidth;
uniform float uLineWidthS;
uniform float uLineWidthT;
uniform int uNumSatellites;
uniform bool bUseSatelliteImage;
uniform bool bFillLand;
uniform bool bFillSeas;
uniform bool bDisplayDayNight;
uniform bool bDisplayLongitudeLatitudeGrid;
uniform bool bDisplayTerminator;
uniform bool bDisplayBoundaries;
uniform bool bDisplayBoundariesCoastlines;
uniform bool bDisplayBoundariesInternal;
float calculateValue(vec4 value) {
return ( value[0] * 256.0 * 256.0 * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[1] * 256.0 * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[2] * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[3] / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE );
}
float calculateDistance(float lat1, float long1, float lat2, float long2) {
return 2.0 * asin( clamp( sqrt( pow( ( sin( ( lat1 - lat2 ) / 2.0) ), 2.0) + cos( lat1 ) * cos( lat2 ) * pow( ( sin( ( long1 - long2 ) / 2.0) ), 2.0 ) ), -1.0, 1.0 ) );
}
void main(void) {
float distance;
float cosDistance;
float longitudeSatellite;
float latitudeSatellite;
float longitudeTexture = 2.0 * PI * ( vTextureCoord.s - 0.5 );
float latitudeTexture = PI * ( vTextureCoord.t - 0.5 );
float sinLatitudeTexture = sin( latitudeTexture );
float cosLatitudeTexture = cos( latitudeTexture );
float cosAngle;
float angle;
vec4 value;
vec4 footprintColor;
vec4 textureColor;
vec2 location;
cosDistance = cos(calculateDistance( latitudeTexture, longitudeTexture, uSolarLatitude, uSolarLongitude ));
if (bUseSatelliteImage) {
if (bDisplayDayNight) {
textureColor = mix( texture2D(uSamplerDay, vTextureCoord), texture2D(uSamplerNight, vTextureCoord), smoothstep(-0.075, 0.075, -cosDistance) );
} else {
textureColor = texture2D(uSamplerDay, vTextureCoord);
}
} else {
if (bDisplayDayNight) {
textureColor = mix( uColorDay, uColorNight, smoothstep(-0.075, 0.075, -cosDistance) );
} else {
textureColor = uColorDay;
}
}
if (bFillLand || bFillSeas) {
float mask = texture2D( uSamplerMask, vTextureCoord ).rgb.r;
if (bFillLand) {
textureColor = mix( textureColor, uColorLand, mask * uColorLand.a );
}
if (bFillSeas) {
textureColor = mix( textureColor, uColorSeas, ( 1.0 - mask ) * uColorSeas.a );
}
}
if ((bDisplayBoundaries && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.r > 0.1) ||
(bDisplayBoundariesCoastlines && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.g > 0.1) ||
(bDisplayBoundariesInternal && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.b > 0.1)) {
textureColor = mix( textureColor, uColorBoundaries, uColorBoundaries.a );
}
if (bDisplayTerminator) {
if (abs(cosDistance) < uLineWidth * PI) {
textureColor = mix( textureColor, uColorTerminator, uColorTerminator.a );
}
}
if (bDisplayLongitudeLatitudeGrid && (uLineWidthS > 0.0 || uLineWidthT > 0.0)) {
if (abs(mod(vTextureCoord.t + uLineWidthT, 1.0 / 6.0)) < 2.0*uLineWidthT) {
textureColor = mix( textureColor, uColorLongitudeLatitudeGrid, uColorLongitudeLatitudeGrid.a );
} else if (abs(mod(vTextureCoord.s + uLineWidthS, 1.0 / 12.0)) < 3.0*uLineWidthS/abs(cos(PI*0.9*(vTextureCoord.t-0.5)))) {
textureColor = mix( textureColor, uColorLongitudeLatitudeGrid, uColorLongitudeLatitudeGrid.a );
}
}
for (int satellite = 0; satellite < int(FOOTPRINTS_ARRAY_NUM_SATELLITES); satellite++) {
if (satellite >= uNumSatellites) {
break;
}
footprintColor = texture2D(uSamplerFootprints, vec2(0.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0));
value = texture2D(uSamplerFootprints, vec2(1.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0));
longitudeSatellite = calculateValue(value);
value = texture2D(uSamplerFootprints, vec2(2.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0));
latitudeSatellite = calculateValue(value) - ( PI / 2.0 );
distance = calculateDistance(latitudeSatellite, longitudeSatellite, latitudeTexture, longitudeTexture);
//
// shade the interior of the footprint...
//
angle = calculateValue(texture2D(uSamplerFootprints, vec2(3.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0)));
if (angle < PI / 2.0) {
if (distance < angle) {
textureColor = mix( textureColor, footprintColor, footprintColor.a );
}
}
//
// outline the satellite footprint at various angles...
//
for (int index=0; index < 4; index++) {
angle = calculateValue(texture2D(uSamplerFootprints, vec2((4.5+float(index))/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0)));
if (angle < PI / 2.0) {
if (distance <= angle + ( uLineWidth * PI ) && distance >= angle - ( uLineWidth * PI ) ) {
textureColor = mix( textureColor, footprintColor, 1.0 );
}
}
}
}
gl_FragColor = vec4(textureColor.rgb, 1);
}
</script> <script id="shader-vs-globe-sinusoidal" type="x-shader/x-vertex">
precision highp float;
attribute vec2 aTextureCoord;
varying vec2 vTextureCoord;
uniform float uCentralLongitude;
const float PI = 3.14159265358979323846264;
const float DELTA = 0.00005;
void main(void) {
float x = ((2.0 * aTextureCoord[0]) - 1.0) * cos((aTextureCoord[1] - 0.5) * PI);
float y = (2.0 * aTextureCoord[1]) - 1.0;
gl_Position = vec4( x, y, 0, 1 );
vTextureCoord = vec2( aTextureCoord[0] + uCentralLongitude, aTextureCoord[1] );
}
</script> <script id="shader-fs-globe-robinson" type="x-shader/x-fragment">
precision highp float;
const float PI = 3.14159265358979323846264;
const float FOOTPRINTS_ARRAY_NUM_SATELLITES = 1024.0;
const float CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE = 672946987.0 / 255.0;
varying vec2 vTextureCoord;
uniform sampler2D uSamplerDay;
uniform sampler2D uSamplerNight;
uniform sampler2D uSamplerMask;
uniform sampler2D uSamplerBoundaries;
uniform sampler2D uSamplerFootprints;
uniform vec4 uColorSeas;
uniform vec4 uColorLand;
uniform vec4 uColorDay;
uniform vec4 uColorNight;
uniform vec4 uColorLongitudeLatitudeGrid;
uniform vec4 uColorTerminator;
uniform vec4 uColorBoundaries;
uniform float uSolarLongitude;
uniform float uSolarLatitude;
uniform float uLineWidth;
uniform float uLineWidthS;
uniform float uLineWidthT;
uniform int uNumSatellites;
uniform bool bUseSatelliteImage;
uniform bool bFillLand;
uniform bool bFillSeas;
uniform bool bDisplayDayNight;
uniform bool bDisplayLongitudeLatitudeGrid;
uniform bool bDisplayTerminator;
uniform bool bDisplayBoundaries;
uniform bool bDisplayBoundariesCoastlines;
uniform bool bDisplayBoundariesInternal;
float calculateValue(vec4 value) {
return ( value[0] * 256.0 * 256.0 * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[1] * 256.0 * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[2] * 256.0 / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE ) +
( value[3] / CONVERT_ANGLE_TO_BYTE_ARRAY_VALUE );
}
float calculateDistance(float lat1, float long1, float lat2, float long2) {
return 2.0 * asin( clamp( sqrt( pow( ( sin( ( lat1 - lat2 ) / 2.0) ), 2.0) + cos( lat1 ) * cos( lat2 ) * pow( ( sin( ( long1 - long2 ) / 2.0) ), 2.0 ) ), -1.0, 1.0 ) );
}
void main(void) {
float distance;
float cosDistance;
float longitudeSatellite;
float latitudeSatellite;
float longitudeTexture = 2.0 * PI * ( vTextureCoord.s - 0.5 );
float latitudeTexture = PI * ( vTextureCoord.t - 0.5 );
float angle;
vec4 value;
vec4 footprintColor;
vec4 textureColor;
cosDistance = cos(calculateDistance( latitudeTexture, longitudeTexture, uSolarLatitude, uSolarLongitude ));
if (bUseSatelliteImage) {
if (bDisplayDayNight) {
textureColor = mix( texture2D(uSamplerDay, vTextureCoord), texture2D(uSamplerNight, vTextureCoord), smoothstep(-0.075, 0.075, -cosDistance) );
} else {
textureColor = texture2D(uSamplerDay, vTextureCoord);
}
} else {
if (bDisplayDayNight) {
textureColor = mix( uColorDay, uColorNight, smoothstep(-0.075, 0.075, -cosDistance) );
} else {
textureColor = uColorDay;
}
}
if (bFillLand || bFillSeas) {
float mask = texture2D( uSamplerMask, vTextureCoord ).rgb.r;
if (bFillLand) {
textureColor = mix( textureColor, uColorLand, mask * uColorLand.a );
}
if (bFillSeas) {
textureColor = mix( textureColor, uColorSeas, ( 1.0 - mask ) * uColorSeas.a );
}
}
if ((bDisplayBoundaries && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.r > 0.1) ||
(bDisplayBoundariesCoastlines && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.g > 0.1) ||
(bDisplayBoundariesInternal && texture2D( uSamplerBoundaries, vTextureCoord ).rgb.b > 0.1)) {
textureColor = mix( textureColor, uColorBoundaries, uColorBoundaries.a );
}
if (bDisplayTerminator) {
if (abs(cosDistance) < uLineWidth * PI) {
textureColor = mix( textureColor, uColorTerminator, uColorTerminator.a );
}
}
if (bDisplayLongitudeLatitudeGrid && (uLineWidthS > 0.0 || uLineWidthT > 0.0)) {
if (abs(mod(vTextureCoord.t + uLineWidthT, 1.0 / 6.0)) < 2.0*uLineWidthT) {
textureColor = mix( textureColor, uColorLongitudeLatitudeGrid, uColorLongitudeLatitudeGrid.a );
} else if (abs(mod(vTextureCoord.s + uLineWidthS, 1.0 / 12.0)) < 3.0*uLineWidthS/abs(cos(PI*0.5*(vTextureCoord.t-0.5)))) {
textureColor = mix( textureColor, uColorLongitudeLatitudeGrid, uColorLongitudeLatitudeGrid.a );
}
}
for (int satellite = 0; satellite < int(FOOTPRINTS_ARRAY_NUM_SATELLITES); satellite++) {
if (satellite >= uNumSatellites) {
break;
}
footprintColor = texture2D(uSamplerFootprints, vec2(0.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0));
value = texture2D(uSamplerFootprints, vec2(1.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0));
longitudeSatellite = calculateValue(value);
value = texture2D(uSamplerFootprints, vec2(2.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0));
latitudeSatellite = calculateValue(value) - ( PI / 2.0 );
distance = calculateDistance(latitudeSatellite, longitudeSatellite, latitudeTexture, longitudeTexture);
//
// shade the interior of the footprint...
//
angle = calculateValue(texture2D(uSamplerFootprints, vec2(3.5/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0)));
if (angle < PI / 2.0) {
if (distance < angle) {
textureColor = mix( textureColor, footprintColor, footprintColor.a );
}
}
//
// outline the satellite footprint at various angles...
//
for (int index=0; index < 4; index++) {
angle = calculateValue(texture2D(uSamplerFootprints, vec2((4.5+float(index))/8.0, (FOOTPRINTS_ARRAY_NUM_SATELLITES - 0.5 - float(satellite))/1024.0)));
if (angle < PI / 2.0) {
if (distance <= angle + ( uLineWidth * PI ) && distance >= angle - ( uLineWidth * PI ) ) {
textureColor = mix( textureColor, footprintColor, 1.0 );
}
}
}
}
gl_FragColor = vec4(textureColor.rgb, 1);
}
</script> <script id="shader-vs-globe-robinson" type="x-shader/x-vertex">
precision highp float;
attribute vec2 aTextureCoord;
varying vec2 vTextureCoord;
uniform float uCentralLongitude;
uniform vec3 uRobinsonMap[19];
const float PI = 3.14159265358979323846264;
const int NUM_ROBINSON_MAP_STEPS = 19;
void main(void) {
float longitudeDegrees = (360.0 * aTextureCoord[0]);
float latitudeDegrees = (180.0 * aTextureCoord[1]) - 90.0;
float x;
float y;
int index;
index = int(abs(latitudeDegrees / (90.0 / float(NUM_ROBINSON_MAP_STEPS-1))));
if (index >= NUM_ROBINSON_MAP_STEPS - 2) {
index = NUM_ROBINSON_MAP_STEPS - 2;
}
x = ( ( ( abs( latitudeDegrees ) - uRobinsonMap[index+0][0] ) * uRobinsonMap[index+1][1] ) +
( ( uRobinsonMap[index+1][0] - abs( latitudeDegrees ) ) * uRobinsonMap[index+0][1] ) ) /
( uRobinsonMap[index+1][0] - uRobinsonMap[index+0][0] );
x *= ( longitudeDegrees / 180.0 ) - 1.0;
y = sign( latitudeDegrees ) * ( ( ( abs( latitudeDegrees ) - uRobinsonMap[index+0][0] ) * uRobinsonMap[index+1][2] ) +
( ( uRobinsonMap[index+1][0] - abs( latitudeDegrees ) ) * uRobinsonMap[index+0][2] ) ) /
( uRobinsonMap[index+1][0] - uRobinsonMap[index+0][0] );
gl_Position = vec4( x, y, 0, 1 );
vTextureCoord = vec2( aTextureCoord[0] + uCentralLongitude, aTextureCoord[1] );
}
</script> <script id="shader-fs-basic" type="x-shader/x-fragment">
precision mediump float;
uniform vec4 uColor;
void main(void) {
gl_FragColor = vec4(uColor.rgb, 0.5);
}
</script> <script id="shader-fs-track-radar" type="x-shader/x-fragment">
precision mediump float;
varying float alpha;
uniform vec4 uColor;
void main(void) {
gl_FragColor = vec4(uColor.rgb, 0.1);
if (alpha == 0.0) {
discard;
}
}
</script> <script id="shader-vs-track-radar" type="x-shader/x-vertex">
attribute vec4 aVertexPosition;
attribute vec4 aVertexPositionPrevNext;
varying float alpha;
uniform vec3 observerLongLatAlt;
uniform float uScaleX;
uniform float uScaleY;
const float PI = 3.14159265358979323846264;
vec3 ToCartesianECEF(float longitudeRadians, float latitudeRadians, float altitudeKms) {
float EARTH_AXIS_RATIO = 0.996647189335;
float EARTH_SEMI_MAJOR_AXIS_KM = 6378.137;
float sinOE = sin( acos( EARTH_AXIS_RATIO ) );
float sinLatitude = sin( latitudeRadians );
float N = EARTH_SEMI_MAJOR_AXIS_KM / sqrt( 1.0 - ( sinLatitude * sinOE * sinLatitude * sinOE ) );
float scaledCosLatitude = ( N + altitudeKms ) * cos( latitudeRadians );
return vec3(scaledCosLatitude * cos( longitudeRadians ) / EARTH_SEMI_MAJOR_AXIS_KM, 
scaledCosLatitude * sin( longitudeRadians ) / EARTH_SEMI_MAJOR_AXIS_KM, 
( ( EARTH_AXIS_RATIO * EARTH_AXIS_RATIO * N ) + altitudeKms ) * sinLatitude / EARTH_SEMI_MAJOR_AXIS_KM );
}
void main(void) {
vec3 xyz[2];
vec3 xyzPrevNext[2];
float alt;
float az;
float azPrevNext;
float x;
float y;
alpha = 1.0;
xyz[0] = vec3(-aVertexPosition[0], aVertexPosition[2], aVertexPosition[1]) - ToCartesianECEF(observerLongLatAlt[0], observerLongLatAlt[1], observerLongLatAlt[2]);
xyzPrevNext[0] = vec3(-aVertexPositionPrevNext[0], aVertexPositionPrevNext[2], aVertexPositionPrevNext[1]) - ToCartesianECEF(observerLongLatAlt[0], observerLongLatAlt[1], observerLongLatAlt[2]);
//
// rotate about the z axis (longitude)...
//
xyz[1].x =  xyz[0].x * cos(observerLongLatAlt[0]) + xyz[0].y * sin(observerLongLatAlt[0]);
xyz[1].y = -xyz[0].x * sin(observerLongLatAlt[0]) + xyz[0].y * cos(observerLongLatAlt[0]);
xyz[1].z =  xyz[0].z;
xyzPrevNext[1].x =  xyzPrevNext[0].x * cos(observerLongLatAlt[0]) + xyzPrevNext[0].y * sin(observerLongLatAlt[0]);
xyzPrevNext[1].y = -xyzPrevNext[0].x * sin(observerLongLatAlt[0]) + xyzPrevNext[0].y * cos(observerLongLatAlt[0]);
xyzPrevNext[1].z =  xyzPrevNext[0].z;
//
// rotate about the y axis (latitude)...
//
xyz[0].x =  xyz[1].x * sin(observerLongLatAlt[1]) - xyz[1].z * cos(observerLongLatAlt[1]);
xyz[0].y =  xyz[1].y;
xyz[0].z =  xyz[1].x * cos(observerLongLatAlt[1]) + xyz[1].z * sin(observerLongLatAlt[1]);
xyzPrevNext[0].x =  xyzPrevNext[1].x * sin(observerLongLatAlt[1]) - xyzPrevNext[1].z * cos(observerLongLatAlt[1]);
xyzPrevNext[0].y =  xyzPrevNext[1].y;
xyzPrevNext[0].z =  xyzPrevNext[1].x * cos(observerLongLatAlt[1]) + xyzPrevNext[1].z * sin(observerLongLatAlt[1]);
//
// convert to spherical coordinates...
//
alt = atan( xyz[0].z, sqrt( (xyz[0].x * xyz[0].x) + (xyz[0].y * xyz[0].y) ) );
az = atan( xyz[0].x, xyz[0].y );
azPrevNext = atan( xyzPrevNext[0].x, xyzPrevNext[0].y );
//
// the following avoids drawing the track where we're around alt = -90
//  and the az value can jump dramtically, leading to a track that
//  jumps from one side of the screen to the other...
//
if (alt < 0.0 && abs(azPrevNext - az) > 0.25 * PI && abs(azPrevNext - az) < 1.75 * PI) {
alpha = 0.0;
}
x = ((PI - (2.0 * alt)) / PI) * cos(az);
y = ((PI - (2.0 * alt)) / PI) * sin(az);
gl_Position = vec4(uScaleX * x, -uScaleY * y, 0.0, 1.0);
}
</script> <script id="shader-vs-xy" type="x-shader/x-vertex">
attribute vec2 aVertexPosition;
uniform float uScaleX;
uniform float uScaleY;
void main(void) {
gl_Position = vec4(uScaleX * aVertexPosition[0], uScaleY * aVertexPosition[1], -0.01, 1);
}
</script> <script id="shader-fs-radec" type="x-shader/x-fragment">
precision mediump float;
varying float clip;
uniform vec4 uColor;
void main(void) {
if (clip > 0.0) {
discard;
}
gl_FragColor = vec4(uColor.rgb, 0.5);
}
</script> <script id="shader-vs-radec" type="x-shader/x-vertex">
const float PI = 3.14159265358979323846264;
attribute vec4 aVertexPosition;
varying float clip;
uniform float thetaG;
uniform float longitude;
uniform float latitude;
uniform float uScaleX;
uniform float uScaleY;
void main(void) {
float sinLat = sin(latitude);
float cosLat = cos(latitude);
float sinHA = sin(thetaG+longitude-aVertexPosition[0]);
float cosHA = cos(thetaG+longitude-aVertexPosition[0]);
float sinDec = sin(aVertexPosition[1]);
float cosDec = cos(aVertexPosition[1]);
float x = -cosHA * cosDec * sinLat + sinDec * cosLat;
float y = -sinHA * cosDec;
float z = cosHA * cosDec * cosLat + sinDec * sinLat;
float r = sqrt((x*x) + (y*y));
float az = atan(y,x);
float alt = atan(z,r);
sinHA = sin(thetaG+longitude-aVertexPosition[2]);
cosHA = cos(thetaG+longitude-aVertexPosition[2]);
sinDec = sin(aVertexPosition[3]);
cosDec = cos(aVertexPosition[3]);
x = -cosHA * cosDec * sinLat + sinDec * cosLat;
y = -sinHA * cosDec;
z = cosHA * cosDec * cosLat + sinDec * sinLat;
r = sqrt((x*x) + (y*y));
float azPrevNext = atan(y,x);
float altPrevNext = atan(z,r);
if (alt <= 0.0 && altPrevNext <= 0.0) {
gl_Position = vec4(0.0, 0.0, -0.01, 1);
clip = 1.0;
} else {
if (alt < 0.0 && altPrevNext > 0.0) {
if (abs(az + (2.0*PI) - azPrevNext) < abs(az - azPrevNext)) {
az += 2.0 * PI;
} else if (abs(az - (2.0*PI) - azPrevNext) < abs(az - azPrevNext)) {
az -= 2.0 * PI;
}
az = ((az/abs(alt)) + (azPrevNext/abs(altPrevNext))) / ((1.0/abs(alt)) + (1.0/abs(altPrevNext)));
alt = 0.0;
}
x = ((PI - (2.0 * alt)) / PI) * cos((PI/2.0) - az);
y = ((PI - (2.0 * alt)) / PI) * sin((PI/2.0) - az);
gl_Position = vec4(uScaleX * x, uScaleY * y, -0.01, 1);
clip = 0.0;
}
}
</script> <script id="shader-fs-stars" type="x-shader/x-fragment">
precision mediump float;
varying float clip;
varying vec3 color;
void main(void) {
if (clip > 0.0) {
discard;
}
gl_FragColor = vec4(color.rgb, 1.0);
}
</script> <script id="shader-vs-stars" type="x-shader/x-vertex">
const float PI = 3.14159265358979323846264;
attribute vec3 aVertexPositionMagnitude;
precision mediump float;
varying float clip;
varying vec3 color;
uniform vec3 colorConstants;
uniform vec3 colorGradients;
uniform float limitingMagnitude;
uniform float thetaG;
uniform float longitude;
uniform float latitude;
uniform float uScaleX;
uniform float uScaleY;
void main(void) {
if (aVertexPositionMagnitude[2] <= limitingMagnitude) {
float sinLat = sin(latitude);
float cosLat = cos(latitude);
float sinHA = sin(thetaG+longitude-aVertexPositionMagnitude[0]);
float cosHA = cos(thetaG+longitude-aVertexPositionMagnitude[0]);
float sinDec = sin(aVertexPositionMagnitude[1]);
float cosDec = cos(aVertexPositionMagnitude[1]);
float x = -cosHA * cosDec * sinLat + sinDec * cosLat;
float y = -sinHA * cosDec;
float z = cosHA * cosDec * cosLat + sinDec * sinLat;
float r = sqrt((x*x) + (y*y));
float az = atan(y,x);
float alt = atan(z,r);
if (alt <= 0.0) {
gl_Position = vec4(0.0, 0.0, -0.01, 1);
clip = 1.0;
} else {
x = ((PI - (2.0 * alt)) / PI) * cos((PI/2.0) - az);
y = ((PI - (2.0 * alt)) / PI) * sin((PI/2.0) - az);
clip = 0.0;
color = clamp(colorConstants + (colorGradients * aVertexPositionMagnitude[2]), vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0));
gl_Position = vec4(uScaleX * x, uScaleY * y, 0.0, 1);
gl_PointSize = 3.0;
}
} else {
gl_Position = vec4(0.0, 0.0, -0.01, 1);
clip = 1.0;
}
}
</script> </head> <body> <main> <div class="loading" id="loading"> <div id="progressOuter"> <progress id="progress" value="0" max="100"></progress> </div> </div> <div id="notification"></div> <div class="buttonContainer" id="buttonContainer"> <div class="button" id="buttonSatellite"></div> <div class="button" id="buttonProjection"></div> <div class="button" id="buttonFullscreen"></div> <div class="button" id="buttonObserver"></div> <div class="button" id="buttonRefresh"></div> <div class="button" id="buttonInformation"></div> <div class="button" id="buttonSettings"></div> </div> <div class="background" id="background"> <div class="report" id="dateandtime"> <img class="dateandtimebutton" id="dateandtimezero" src="Time/Reset128.png"/> <img class="dateandtimebutton" id="dateandtimeplay" src="Time/Pause128.png"/> <span id="dateandtimewrapper"> <span id="dateandtimeyear">&ndash;&ndash;&ndash;&ndash;</span>&ndash;<span id="dateandtimemonth">&ndash;&ndash;</span>&ndash;<span id="dateandtimeday">&ndash;&ndash;</span> <span id="dateandtimehour">&ndash;&ndash;</span>&colon;<span id="dateandtimeminute">&ndash;&ndash;</span>&colon;<span id="dateandtimesecond">&ndash;&ndash;</span> </span> </div> <div id="modifytime"> <span class="modifyTime" id="addDay">&plus;</span> <span class="modifyTime" id="addHour">&plus;</span> <span class="modifyTime" id="addMinute">&plus;</span> <span class="modifyTime" id="subtractDay">&minus;</span> <span class="modifyTime" id="subtractHour">&minus;</span> <span class="modifyTime" id="subtractMinute">&minus;</span> </div> <div class="report" id="lonandlat">&ndash;</div> <div class="report" id="position">&ndash;</div> <div class="report" id="copyright">&copy; Copyright Sumus Technology Limited 2017-2021</div> <div class="divPopupSettings" id="divSatelliteSettings"> <form class="formPopupSettings"> <div class="title">Satellite settings:</div><br/> <div class="divSatellitesPropertiesRow"> <label class="divLabelPrimary">Satellite</label> <span class="grouping" id="satelliteGroupColor"> <label class="divLabel">color</label> <input class="color" type="color" id="colorSatellite" value="#ff0000" autocomplete="off"/> </span> <span class="grouping" id="satelliteGroupLabel"> <label class="switch"> <input type="checkbox" id="satelliteLabel"/> <span class="slider round"></span> </label> <label class="divLabel" for="satelliteLabel">display label</label> </span> <span class="grouping" id="satelliteGroupLabelBackground"> <label class="switch"> <input type="checkbox" id="satelliteLabelBackground"/> <span class="slider round"></span> </label> </span> <span class="grouping" id="satelliteGroupLabelBackgroundColor"> <label class="divLabel" for="satelliteLabel">with background color</label> <input class="color" type="color" id="colorSatelliteLabelBackground" value="#000000" autocomplete="off"/> </span> </div> <div class="divSatellitesPropertiesRow"> <label class="divLabelPrimary">Symbol</label> <span class="grouping" id="satelliteGroupSymbol"> <img class="divSymbol" id="shapeNone" src="Shapes\ShapeNone.png"/> <img class="divSymbol" id="shapeCircle" src="Shapes\ShapeCircle.png"/> <img class="divSymbol" id="shapeSquare" src="Shapes\ShapeSquare.png"/> <img class="divSymbol" id="shapeTriangle" src="Shapes\ShapeTriangle.png"/> <img class="divSymbol" id="shapeInvertedTriangle" src="Shapes\ShapeInvertedTriangle.png"/> <img class="divSymbol" id="shapeCross" src="Shapes\ShapeCross.png"/> <img class="divSymbol" id="shapePlus" src="Shapes\ShapePlus.png"/> <img class="divSymbol" id="shapeDiamond" src="Shapes\ShapeDiamond.png"/> <img class="divSymbol" id="shapeAsterisk" src="Shapes\ShapeAsterisk.png"/> <img class="divSymbol" id="shapeLeftTriangle" src="Shapes\ShapeLeftTriangle.png"/> <img class="divSymbol" id="shapeRightTriangle" src="Shapes\ShapeRightTriangle.png"/> </span> </div> <div class="divSatellitesPropertiesRow"> <label class="divLabelPrimary">Footprint</label> <span class="grouping" id="satelliteGroupShade"> <label class="switch"> <input type="checkbox" id="satelliteShade"/> <span class="slider round"></span> </label> <label class="divLabel">shade</label> </span> <span class="grouping" id="satelliteGroupAlpha"> <span class="divLabel">&alpha;: </span> <input class="range" type="range" id="satelliteFootprintAlpha" name="satelliteFootprintAlpha" autocomplete="off" min="0" max="1" step="0.01" value="0.4"/> <output class="divValue" for="satelliteFootprintAlpha" name="satelliteFootprintAlphaValue" id="satelliteFootprintAlphaValue">0.4</output> </span> <span class="grouping" id="satelliteGroupOutline"> <label class="switch"> <input type="checkbox" id="satelliteOutline"/> <span class="slider round"></span> </label> <label class="divLabel">outline</label> </span> <span class="grouping" id="satelliteGroupOutlineAngles"> <input class="inputEntry" type="text" id="satelliteOutlineAngles" autocomplete="off" title="Comma separated list of azimuth angles"/> </span> </div> <div class="divSatellitesPropertiesRow"> <label class="divLabelPrimary">Track</label> <span class="grouping" id="satelliteGroupTrackForward"> <input class="inputEntry" type="number" min="0" max="99" step="any" value="0.5" id="satelliteTrackForwardCount" title="Number of minutes/orbits to track forward"/> <label class="divLabel">forward</label> </span> <span class="grouping" id="satelliteGroupTrackBackward"> <input class="inputEntry" type="number" min="0" max="99" step="any" value="0.5" id="satelliteTrackBackwardCount" title="Number of minutes/orbits to track backward"/> <label class="divLabel">backward</label> </span> <span class="grouping" id="satelliteGroupTrackUnits"> <select class="inputSelect" id="satelliteTrackUnits"> <option value="" selected disabled hidden></option> <option value="orbits">orbits</option> <option value="minutes">minutes</option> <option value="hours">hours</option> <option value="days">days</option> </select> </span> </div> <div class="divSatellitesPropertiesRow"> <label class="divLabelPrimary" style="opacity: 0">Track</label> <span class="grouping" id="satelliteGroupTrackStyle"> <label class="divLabel">style</label> <select class="inputSelect" id="satelliteTrackStyle"> <option value="" selected disabled hidden></option> <option value="ground">ground only</option> <option value="aerial">aerial only</option> <option value="both">ground and aerial</option> <option value="joined">ground and aerial joined</option> </select> </span> </div> <input class="divButton divButtonLeft" type="button" id="setDefaultSatelliteSettings" value="Set default"> <input class="divButton divButtonRight" type="button" id="doneSatelliteSettings" value="Done"> <input class="divButton divButtonRight" type="button" id="resetSatelliteSettings" value="Reset"> </form> </div> <div class="divPopupSettings" id="divObserverSettings"> <form class="formPopupSettings"> <div class="title">Observer settings:</div><br/> <div class="divObserversPropertiesRow"> <label class="divLabelPrimary">Observer</label> <span class="grouping" id="observerGroupColor"> <label class="divLabel">color</label> <input class="color" type="color" id="colorObserver" value="#ff0000" autocomplete="off"/> </span> <span class="grouping" id="observerGroupLabel"> <label class="switch"> <input type="checkbox" id="observerLabel"/> <span class="slider round"></span> </label> <label class="divLabel" for="observerLabel">display label</label> </span> <span class="grouping" id="observerGroupLabelBackground"> <label class="switch"> <input type="checkbox" id="observerLabelBackground"/> <span class="slider round"></span> </label> </span> <span class="grouping" id="observerGroupLabelBackgroundColor"> <label class="divLabel" for="observerLabel">with background color</label> <input class="color" type="color" id="colorObserverLabelBackground" value="#000000" autocomplete="off"/> </span> </div> <div class="divObserversPropertiesRow"> <label class="divLabelPrimary">Symbol</label> <span class="grouping" id="observerGroupSymbol"> <img class="divSymbol" id="shapeNoneObserver" src="Shapes\ShapeNone.png"/> <img class="divSymbol" id="shapeCircleObserver" src="Shapes\ShapeCircle.png"/> <img class="divSymbol" id="shapeSquareObserver" src="Shapes\ShapeSquare.png"/> <img class="divSymbol" id="shapeTriangleObserver" src="Shapes\ShapeTriangle.png"/> <img class="divSymbol" id="shapeInvertedTriangleObserver" src="Shapes\ShapeInvertedTriangle.png"/> <img class="divSymbol" id="shapeCrossObserver" src="Shapes\ShapeCross.png"/> <img class="divSymbol" id="shapePlusObserver" src="Shapes\ShapePlus.png"/> <img class="divSymbol" id="shapeDiamondObserver" src="Shapes\ShapeDiamond.png"/> <img class="divSymbol" id="shapeAsteriskObserver" src="Shapes\ShapeAsterisk.png"/> <img class="divSymbol" id="shapeLeftTriangleObserver" src="Shapes\ShapeLeftTriangle.png"/> <img class="divSymbol" id="shapeRightTriangleObserver" src="Shapes\ShapeRightTriangle.png"/> </span> </div> <input class="divButton divButtonRight" type="button" id="doneObserverSettings" value="Done"> <input class="divButton divButtonRight" type="button" id="resetObserverSettings" value="Reset"> </form> </div> <div class="frameouter" id="frameouter"> <div class="buttonScreenClose" id="buttonScreenClose">&cross;</div> <div class="buttonScreen" id="itemFindSatellite"> <div class="frameleft" id="frameleft"> <div class="title">Search all satellites:</div> <table class="searchTable"> <tr> <td class="textEntry">for:&nbsp;</td> <td> <input type=text class="inputEntry" id="searchSatelliteFor"/> </td> </tr> <tr> <td class="textEntry">by:&nbsp;</td> <td> <select class="inputEntry" id="searchSatelliteBy"></select> </td> </tr> <tr> <td class="textEntry">is:&nbsp;</td> <td> <label class="switch"> <input type="checkbox" id="searchOnOrbit" checked/> <span class="slider round"></span> </label> <label class="divLabel" for="searchOnOrbit">on orbit</label> <label class="switch"> <input type="checkbox" id="searchPayload"/> <span class="slider round"></span> </label> <label class="divLabel" for="searchPayload">payload</label> <label class="switch"> <input type="checkbox" id="searchActive"/> <span class="slider round"></span> </label> <label class="divLabel" for="searchActive">active</label> </td> </tr> </table> <div class="title" style="padding-top:20px; padding-top:1vw">Browse on orbit satellites:</div> <div class="displayedSatellites" id="displayedSatellites"></div> <div class="categorySatellites" id="categorySatellites"></div> </div> <div class="frameright" id="frameright"> <div style="white-space: no-wrap"> <div class="objectSettings" id="satelliteSettings">&#9967;&nbsp;</div> <div class="title" style="display:inline" id="results">Results:</div> </div> <div class="frametable" id="frametable"> <div class="divSatellitesHead" id="divSatellitesHead"> <table class="tableHeadSatellites" id="tableHeadSatellites"></table> </div> <div class="divSatellitesBody" id="divSatellitesBody"> <table class="tableBodySatellites" id="tableBodySatellites"></table> </div> </div> </div> </div> <div class="buttonScreen" id="itemSelectObserver"> <div class="buttonScreenInner" id="itemSelectObserverInner"> <div style="white-space: no-wrap"> <div class="objectSettings" id="observerSettings">&#9967;&nbsp;</div> <div class="title" style="display:inline">Location:</div><br/> </div> <form class="formSettings" id="formCenterSettings"> <div class="divRow"> <label class="divLabel">Name</label> <input type=text class="inputEntry" id="observerName" autocomplete="off" maxlength="20" value=""/> </div> <div class="divRow"> <label class="divLabel">Longitude</label> <label class="switch"> <input type="radio" id="observerLonEast" name="settingObserverLon"/> <span class="slider square"></span> </label> <label class="divLabel" for="observerLonEast">East</label> <label class="switch"> <input type="radio" id="observerLonWest" name="settingObserverLon"/> <span class="slider square"></span> </label> <label class="divLabel" for="observerLonWest">West</label> <input type=number class="inputEntry" id="observerLonDegrees" min="0" max="180" step="1" value="0"/> <label class="divLabel">&deg;</label> <label class="divLabel" id="observerLonDMS"></label> </div> <div class="divRow"> <label class="divLabel">Latitude</label> <label class="switch"> <input type="radio" id="observerLatNorth" name="settingObserverLat"/> <span class="slider square"></span> </label> <label class="divLabel" for="observerLatNorth">North</label> <label class="switch"> <input type="radio" id="observerLatSouth" name="settingObserverLat"/> <span class="slider square"></span> </label> <label class="divLabel" for="observerLatSouth">South</label> <input type=number class="inputEntry" id="observerLatDegrees" min="0" max="90" step="1" value="0"/> <label class="divLabel">&deg;</label> <label class="divLabel" id="observerLatDMS"></label> </div> <div class="divRow"> <label class="divLabel">Altitude</label> <input type=number class="inputEntry" id="observerAltitude" min="-10000000" max="10000000" step="100" value="0"/> <label class="divLabel">meters</label> </div> <div class="divRow"> <input class="divButton" type="button" id="applyObserverPositionSettings" value="Apply"> <input class="divButton" type="button" id="resetObserverPositionSettings" value="Reset"> <input class="divButton" type="button" id="useDeviceLocation" value="Use device's location"> </div> </form> <div id="mapObserver" style="display: none"></div> </div> </div> <div class="buttonScreen" id="itemSelectProjection"> <div class="buttonScreenInner"> <div class="divProjection" id="projectionPerspective"><div class="divProjectionInner" id="projectionPerspectiveInner"></div><div class="divProjectionText">Perspective projection: similar to when the Earth is viewed from space.</div></div> <div class="divProjection" id="projectionCylindrical"><div class="divProjectionInner" id="projectionCylindricalInner"></div><div class="divProjectionText">Cylindrical projection: in particular an equirectangular projection.</div></div> <div class="divProjection" id="projectionRobinson"><div class="divProjectionInner" id="projectionRobinsonInner"></div><div class="divProjectionText">Robinson projection, devised by Arthur H. Robinson in 1963. Neither equal-area nor conformal, it abandons both for a compromise.</div></div> <div class="divProjection" id="projectionElliptical"><div class="divProjectionInner" id="projectionEllipticalInner"></div><div class="divProjectionText">Elliptical projection (also called the Mollweide, Babinet, or homalographic projection) is an equal&dash;area projection.</div></div> <div class="divProjection" id="projectionSinusoidal"><div class="divProjectionInner" id="projectionSinusoidalInner"></div><div class="divProjectionText">Sinusoidal projection (also called the Sanson&dash;Flamsteed or the Mercator equal&dash;area projection) is an equal&dash;area projection.</div></div> <div class="divProjection" id="projectionRadar"><div class="divProjectionInner" id="projectionRadarInner"></div><div class="divProjectionText">Radar projection, a view from the observer's perspective with the center of the view directly overhead and the outermost full circle being the horizon.</div></div> <div class="divProjection" id="projectionTextual"><div class="divProjectionInner" id="projectionTextualInner"></div><div class="divProjectionText">Textual view, a table giving various satellite orbital properties.</div></div> </div> </div> <div class="buttonScreen" id="itemInformation"> <div class="buttonScreenInner" id="itemInformationInner"> <p>STL Tracker Online provides satellite tracking capabilities from within your browser. The purpose of each of the buttons located at the top-left of the display are described below:</p> <p>&nbsp;</p> <div class="divInformationTopic"><img class="divInformationImage" src="Buttons/Satellite.png"/><div class="divInformationTitle">Satellites:</div></div> <div class="divInformationContent"> The Satellites configuration screen is broadly split into the left (or top in a vertically oriented screen) side of the screen, which is used to select the satellites of interest, and the right (or bottom) side of the screen, which displays the selected satellites and provides sorting, display, and configuration options. <ul> <li>Search all satellites: Search all satellites by Name, <a href="https://en.wikipedia.org/wiki/Satellite_Catalog_Number" target="_blank" rel="noopener">NORAD Id/Catalog number</a>, or <a href="https://en.wikipedia.org/wiki/International_Designator" target="_blank" rel="noopener">International designator</a>. You can also restrict the search results to satellites that are: <ul> <li>on orbit - if checked excludes objects that have decayed or are no longer in orbit around the Earth</li> <li>payload - if checked excludes debris, rocket boosters, <em>etc.</em></li> <li>active - if checked excludes non-functional objects</li> </ul> Enter the text you want to search for and hit the 'Enter' key. The search results will be displayed in the Results table.</li> <li>Browse orbiting satellites: Select one the categories to display the satellites within that category in the Results table. 'Displayed' will give all the satellites currently being displayed on-screen. 'All' displays all the satellites currently in orbit. Underneath 'All' are hierarchically arranged sub-categories.</li> <li>Results: Displays the results from the Search or Browse. <ul> <li>The results can be sorted by any column by clicking on the associated sort indicator, <img class="divInformationInlineImage" src="Sort/UpDown.png"/>.</li> <li>For orbiting satellites the 'Display' option can be toggled to display/hide the satellite within the view.</li> <li>Decayed satellites are displayed in gray text and the Display option is not available.</li> <li>Hitting the 'i' key with a satellite selected (or tapping on a satellite) will open a new browser page with the <a href="https://nssdc.gsfc.nasa.gov/" target="_blank" rel="noopener">NASA Space Science Data Coordinated Archive (NSSDCA)</a> information on that satellite.</li> <li>Clicking on the <img class="divInformationInlineImage" src="Buttons/Settings.png"/> symbol at the upper left of the Results table allows various visual settings of the satellites selected for Display to be modified. <ul> <li>Satellite: <ul> <li>color - the color used to display the satellite symbol, footprint, tracks, and text label</li> <li>display label - whether or not the satellite name is displayed</li> <li>with background color - background color for satellite name, if displayed</li> </ul> </li> <li>Symbol: the symbol used for displaying the satellite(s), including an initial blank option </li> <li>Footprint: <ul> <li>shade - whether or not the satellite footprint is shaded</li> <li>&alpha; - the alpha value for the shaded satellite footprint, if any</li> <li>outline - whether or not the satellite footprint is outlined and (optionally) a list of comma-seperated values giving the elevation angles to draw the outline for (default = '0')</li> </ul> </li> <li>Track: <ul> <li>forward - length of track to draw forward of the satellite position</li> <li>backward - length of track to draw backward of the satellite position</li> <li>units - the units used for drawing the satellite tracks, which can be one of orbits, days, hours, or minutes</li> <li>style - applies only to the Perspective projection. Can be one of ground only, aerial only, ground and aerial, or ground and aerial joined</li> </ul> </li> </ul> </li> </ul> </li> </ul> </div> <div class="divInformationTopic"><img class="divInformationImage" src="Buttons/Projection.png"/><div class="divInformationTitle">Projection:</div></div> <div class="divInformationContent">Allows selection of one of the supported projections, each of which has an associated explanatory image and brief description.</div> <div class="divInformationTopic"><img class="divInformationImage" src="Buttons/Fullscreen.png"/><div class="divInformationTitle">Fullscreen:</div></div> <div class="divInformationContent">Toggles the full-screen mode on and off. When in full-screen mode the button image is changed to <img class="divInformationInlineImage" src="Buttons/ExitFullscreen.png"/>.</div> <div class="divInformationTopic"><img class="divInformationImage" src="Buttons/Antenna.png"/><div class="divInformationTitle">Observer:</div></div> <div class="divInformationContent">Specifies the location of the observer, which can be provided as either a longitude, latitude, and altitude (in meters) or by selecting the desired position on the associated map. The observer's position is denoted using the icon in the perspective and projection views, as well as for calculating observer-based properties such as azimuth, elevation, range, and range rate for the selected satellite. </div> <div class="divInformationTopic"><img class="divInformationImage" src="Buttons/Refresh.png"/><div class="divInformationTitle">Refresh:</div></div> <div class="divInformationContent">Reloads the satellite TLE and catalog information and refreshes the display.</div> <div class="divInformationTopic"><img class="divInformationImage" src="Buttons/Information.png"/><div class="divInformationTitle">Information:</div></div> <div class="divInformationContent">This is used to display the information that you are currently reading.</div> <div class="divInformationTopic"><img class="divInformationImage" src="Buttons/Settings.png"/><div class="divInformationTitle">Settings:</div></div> <div class="divInformationContent">These settings are applied to the view. Not all settings are applicable in all projections. <ul> <li>Visual settings: <ul> <li>Background color - background color of view</li> <li>Display Earth - show/hide the Earth <ul> <li>Display satellite image - show/hide satellite imagery</li> <li>Display day/night - show/hide day/night imagery. If shown and satellite imagery is hidden uses the assoicated colors for day/night </li> <li>Display terminator - show/hide the terminator (line separating the illuminated day side and the dark night side)</li> <li>Display latitude/longitude grid - show/hide lines of longitude and latitude</li> <li> Display political boundaries - show/hide political boundaries <ul> <li>Include coastlines, islands, and lakes - show/hide coastlines</li> <li>Include selected internal boundaries - show/hide selected internal boundaries</li> </ul> </li> <li>Fill land - show/hide land</li> <li>Fill seas - show/hide seas</li> </ul> </li> </ul> </li> <li>Radar settings: <ul> <li>Display stars - show/hide stars within observer's view <ul> <li>Limiting magnitude - faintest magnitude of stars to be displayed</li> </ul> </li> <li>Display constellations - show/hide constellations within observer's view <ul> <li>Include boundaries - show/hide constellation boundaries</li> <li>Include names - show/hide constellation names</li> </ul> </li> <li>Display altitude and azimuth grid - show/hide altitude and azimuth grid</li> <li>Display R.A. and declination grid - show/hide R.A. and declination grid</li> <li>Display central position - show/hide central position</li> </ul> </li> <li>Textual settings:</li> <li>Other settings: <ul> <li>Display Coordinated Universal Time (UTC/GMT) - if set the time will be displayed as UTC, else in the default timezone. </li> <li>Apply refraction correction - account for atmospheric refraction when displaying satellite footprints.</li> </ul> </li> </ul> </div> <div class="divInformationTopic"><img class="divInformationImage" src="Buttons/Empty.png"/><div class="divInformationTitle">Credits:</div></div> <div class="divInformationContent"> <ul> <li>The Simplified General Perturbations model used was taken from Revisiting Spacetrack Report #3: Rev 2 (American Institute of Aeronautics and Astronautics 2006-6753-Rev1) by David A. Vallado <em>et al.</em></li> <li>Satellite two-line element (TLE) information is acquired from <a href="www.celestrak.com" target="_blank">CelesTrak</a> and <a href="www.space-track.org" target="_blank">Space Track</a></li> <li>Earth imagery is owned by NASA and is made available courtesy of the <a href="http://visibleearth.nasa.gov" target="_blank">NASA Visible Earth</a> team</li> <li>Matrix manipulation is performed in part by <a href="https://github.com/toji/gl-matrix" target="_blank">gl-matrix</a>: <p>Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> </li> <li>Data zlib decompression is performed by <a href="https://github.com/nodeca/pako" target="_blank">pako</a>: <p>Copyright (C) 2014-2017 by Vitaly Puzrin and Andrei Tuputcyn</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> </li> <li>Additional satellite information is provided to the user through <a href="nssdc.gsfc.nasa.gov" target="_blank">NASA's National Space Science Data Center</a></li> <li>Constellation boundary data was derived from a catalog compiled by A.C. Davenhall and S.K. Leggett in 1989</li> <li>Satellite dish icon made available by <a href="http://www.devcom.com" target="_blank">DevCom Ltd.</a> under a <a href="http://creativecommons.org/licenses/by/3.0/" target="_blank">CC Attribution 3.0 license</a></li> <li>Satellite icon made available by <a href="http://www.iconshock.com" target="_blank">Iconshock</a> under the the terms of their <a href="http://www.iconshock.com/license.php" target="_blank">license agreement</a></li> </ul> </div> <div class="divInformationTopic"><img class="divInformationImage" src="Buttons/Empty.png"/><div class="divInformationTitle">Copyright:</div></div> <div class="divInformationContent"> <ul> <li>&copy; Copyright Sumus Technology Limited 2017-2021</li> <li>All rights reserved</li> </ul> </div> </div> </div> <div class="buttonScreen" id="itemSettings"> <div class="buttonScreenInner" id="itemSettingsInner"> <div id="settingsVisual"> <div class="titleSettings">Visual settings:</div> <form class="formSettings" id="formVisualSettings"> <div class="divRow"> <label class="switch" style="visibility: hidden"> <input type="checkbox" id="displayBackground" checked/> <span class="slider round"></span> </label> <label class="divLabel" for="displayBackground">Background color</label> <input class="color" type="color" id="colorBackground" value="#ff0000" autocomplete="off"/> </div> <div class="divRow"> <label class="switch"> <input type="checkbox" id="displayEarth"> <span class="slider round"></span> </label> <label class="divLabel" for="displayEarth">Display Earth</label><br/> </div> <div class="divRowIndented"> <div class="divRow"> <label class="switch"> <input type="checkbox" id="displayImage"> <span class="slider round"></span> </label> <label class="divLabel" for="displayImage">Display satellite image</label><br/> </div> <div class="divRow"> <label class="switch"> <input type="checkbox" id="displayDayNight"> <span class="slider round"></span> </label> <label class="divLabel" for="displayDayNight">Display day/night</label> <input class="color" type="color" id="colorDay" value="#ff0000" autocomplete="off"/> <input class="color" type="color" id="colorNight" value="#ff0000" autocomplete="off"/> </div> <div class="divRow"> <label class="switch"> <input type="checkbox" id="displayTerminator"> <span class="slider round"></span> </label> <label class="divLabel" for="displayTerminator">Display terminator</label> <input class="color" type="color" id="colorTerminator" value="#ff0000" autocomplete="off"> <div class="divAlphaTitle">&alpha;: </div> <input class="range" type="range" id="alphaTerminator" autocomplete="off" min="0" max="1" step="0.01" value="0"/> <output class="divValue" name="alphaTerminatorValue" id="alphaTerminatorValue"></output> </div> <div class="divRow"> <label class="switch"> <input type="checkbox" id="displayLatLongGrid"> <span class="slider round"></span> </label> <label class="divLabel" for="displayLatLongGrid">Display latitude/longitude grid</label> <input class="color" type="color" id="colorLatLongGrid" value="#ff0000" autocomplete="off"/> <div class="divAlphaTitle">&alpha;: </div> <input class="range" type="range" id="alphaLatLongGrid" autocomplete="off" min="0" max="1" step="0.01" value="0"/> <output class="divValue" name="alphaLatLongGridValue" id="alphaLatLongGridValue"></output> </div> <div class="divRow"> <label class="switch"> <input type="checkbox" id="displayBoundaries"> <span class="slider round"></span> </label> <label class="divLabel" for="displayBoundaries">Display political boundaries</label> <input class="color" type="color" id="colorBoundaries" value="#ff0000" autocomplete="off"/> <div class="divAlphaTitle">&alpha;: </div> <input class="range" type="range" id="alphaBoundaries" autocomplete="off" min="0" max="1" step="0.01" value="0"/> <output class="divValue" name="alphaBoundariesValue" id="alphaBoundariesValue"></output> </div> <div class="divRowIndented"> <label class="switch"> <input type="checkbox" id="displayBoundariesCoastline"> <span class="slider round"></span> </label> <label class="divLabel" for="displayBoundariesCoastline">Include coastlines, islands, and lakes</label><br/> </div> <div class="divRowIndented"> <label class="switch"> <input type="checkbox" id="displayBoundariesInternal"> <span class="slider round"></span> </label> <label class="divLabel" for="displayBoundariesInternal">Include selected internal boundaries</label><br/> </div> <div class="divRow"> <label class="switch"> <input type="checkbox" id="displayFillLand"> <span class="slider round"></span> </label> <label class="divLabel" for="displayFillLand">Fill land</label> <input class="color" type="color" id="colorLand" value="#ff0000" autocomplete="off"/> <div class="divAlphaTitle">&alpha;: </div> <input class="range" type="range" id="alphaFillLand" autocomplete="off" min="0" max="1" step="0.01" value="0"/> <output class="divValue" name="alphaFillLandValue" id="alphaFillLandValue"></output> </div> <div class="divRow"> <label class="switch"> <input type="checkbox" id="displayFillSeas"> <span class="slider round"></span> </label> <label class="divLabel" for="displayFillSeas">Fill seas</label> <input class="color" type="color" id="colorSeas" value="#ff0000" autocomplete="off"/> <div class="divAlphaTitle">&alpha;: </div> <input class="range" type="range" id="alphaFillSeas" name="alphaFillSeas" autocomplete="off" min="0" max="1" step="0.01" value="0"/> <output class="divValue" name="alphaFillSeasValue" id="alphaFillSeasValue"></output> </div> </div> </form> </div> <div id="settingsRadar"> <div class="titleSettings">Radar settings:</div> <form class="formSettings" id="formRadarSettings"> <div class="divRow"> <label class="switch" style="visibility: hidden"> <input type="checkbox" id="displayBackgroundRadar" checked/> <span class="slider round"></span> </label> <label class="divLabel" for="displayBackgroundRadar">Background color</label> <input class="color" type="color" id="colorBackgroundRadar" value="#ff0000" autocomplete="off"/> </div> <div class="divRow"> <label class="switch"> <input type="checkbox" id="displayStars"> <span class="slider round"></span> </label> <label class="divLabel" for="displayStars">Display stars</label> <input class="color" type="color" id="colorStars" value="#ff0000" autocomplete="off"> </div> <div class="divRowIndented"> <div class="divRow"> <div class="divAlphaTitle">Limiting magnitude: </div> <input class="range" type="range" id="limitingMagnitude" name="limitingMagnitude" autocomplete="off" min="0" max="6" step="0.5" value="6"/> <output class="divValue" name="limitingMagnitudeValue" id="limitingMagnitudeValue"></output> </div> </div> <div class="divRow"> <label class="switch"> <input type="checkbox" id="displayConstellations"> <span class="slider round"></span> </label> <label class="divLabel" for="displayConstellations">Display constellations</label> <input class="color" type="color" id="colorConstellations" value="#ffffff" autocomplete="off"> </div> <div class="divRowIndented"> <div class="divRow"> <label class="switch"> <input type="checkbox" id="includeConstellationBoundaries"> <span class="slider round"></span> </label> <label class="divLabel" for="includeConstellationBoundaries">Include boundaries</label> <input class="color" type="color" id="colorConstellationBoundaries" value="#ff0000" autocomplete="off"/> </div> </div> <div class="divRowIndented"> <div class="divRow"> <label class="switch"> <input type="checkbox" id="includeConstellationNames"> <span class="slider round"></span> </label> <label class="divLabel" for="includeConstellationNames">Include names</label> <input class="color" type="color" id="colorConstellationNames" value="#ff0000" autocomplete="off"/> </div> </div> <div class="divRow"> <label class="switch"> <input type="checkbox" id="displayAzElGrid"> <span class="slider round"></span> </label> <label class="divLabel" for="displayAzElGrid">Display altitude and azimuth grid</label> <input class="color" type="color" id="colorAzElGrid" value="#ff0000" autocomplete="off"/> </div> <div class="divRow"> <label class="switch"> <input type="checkbox" id="displayRADecGrid"> <span class="slider round"></span> </label> <label class="divLabel" for="displayRADecGrid">Display R.A. and declination grid</label> <input class="color" type="color" id="colorRADecGrid" value="#ff0000" autocomplete="off"/> </div> <div class="divRow"> <label class="switch"> <input type="checkbox" id="displayCentralPosition" autocomplete="off"> <span class="slider round"></span> </label> <label class="divLabel" for="displayCentralPosition">Display central position</label> <input class="color" type="color" id="colorCentralPosition" value="#ff0000" autocomplete="off"/> </div> </form> </div> <div id="settingsTextual"> <div class="titleSettings">Textual settings:</div> </div> <div class="titleSettings">Other settings:</div> <form class="formSettings" id="formOtherSettings"> <div class="divRow"> <label class="switch"> <input type="checkbox" id="timeZoneUTC"> <span class="slider round"></span> </label> <label class="divLabel" for="timeZoneUTC">Display Coordinated Universal Time (UTC/GMT)</label> </div> <div class="divRow"> <label class="switch"> <input type="checkbox" id="refractionCorrection"> <span class="slider round"></span> </label> <label class="divLabel" for="refractionCorrection">Apply refraction correction</label> </div> </form> </div> </div> </div> <div id="labelContainer"></div> <div id="container"> <canvas id="canvas"></canvas> </div> <div class="divTableTextualOuter" id="divTableTextualOuter"> <div class="divTableTextual" id="divTableTextual"> <div class="divTableHeadTextual" id="divTableHeadTextual"> <table class="tableHeadTextual" id="tableHeadTextual"></table> </div> <div class="divTableBodyTextual" id="divTableBodyTextual"> <table class="tableBodyTextual" id="tableBodyTextual"></table> </div> </div> </div> <div id="radarText"> <div id="radarCenter" class="radarCenter"></div> <div id="radarLabels"> <div alt="-90" az="270" class="radarLabel" xOffset="0" yOffset="0">-90</div> <div alt="-60" az="270" class="radarLabel" xOffset="0" yOffset="0">-60</div> <div alt="-30" az="270" class="radarLabel" xOffset="0" yOffset="0">-30</div> <div alt="0" az="270" class="radarLabel" xOffset="0" yOffset="0">0</div> <div alt="30" az="270" class="radarLabel" xOffset="0" yOffset="0">30</div> <div alt="60" az="270" class="radarLabel" xOffset="0" yOffset="0">60</div> <div alt="-90" az="90" class="radarLabel" xOffset="-100" yOffset="0">-90</div> <div alt="-60" az="90" class="radarLabel" xOffset="-100" yOffset="0">-60</div> <div alt="-30" az="90" class="radarLabel" xOffset="-100" yOffset="0">-30</div> <div alt="0" az="90" class="radarLabel" xOffset="-100" yOffset="0">0</div> <div alt="30" az="90" class="radarLabel" xOffset="-100" yOffset="0">30</div> <div alt="60" az="90" class="radarLabel" xOffset="-100" yOffset="0">60</div> <div alt="0" az="45" class="radarLabel" xOffset="0" yOffset="-25">45</div> <div alt="0" az="135" class="radarLabel" xOffset="0" yOffset="-25">135</div> <div alt="0" az="225" class="radarLabel" xOffset="-100" yOffset="-25">225</div> <div alt="0" az="315" class="radarLabel" xOffset="-100" yOffset="-25">315</div> <div alt="0" az="0" class="radarLabel" xOffset="0" yOffset="0">N</div> <div alt="0" az="90" class="radarLabel" xOffset="-100" yOffset="-100">E</div> <div alt="0" az="180" class="radarLabel" xOffset="-100" yOffset="-100">S</div> <div alt="0" az="270" class="radarLabel" xOffset="0" yOffset="-100">W</div> </div> <div id="constellationLabels"> <div ra="0.139" dec="0.698" fullName="Andromeda" abbr="And" class="textConstellationLabel"></div> <div ra="2.683" dec="-0.611" fullName="Antila" abbr="Ant" class="textConstellationLabel"></div> <div ra="4.152" dec="-1.326" fullName="Apus" abbr="Aps" class="textConstellationLabel"></div> <div ra="5.927" dec="-0.209" fullName="Aquarius" abbr="Aqr" class="textConstellationLabel"></div> <div ra="5.157" dec="-0.000" fullName="Aquila" abbr="Aql" class="textConstellationLabel"></div> <div ra="4.503" dec="-0.908" fullName="Ara" abbr="Ara" class="textConstellationLabel"></div> <div ra="0.681" dec="0.349" fullName="Aries" abbr="Ari" class="textConstellationLabel"></div> <div ra="1.466" dec="0.785" fullName="Auriga" abbr="Aur" class="textConstellationLabel"></div> <div ra="3.822" dec="0.524" fullName="Bo&ouml;tes" abbr="Boo" class="textConstellationLabel"></div> <div ra="1.230" dec="-0.681" fullName="Caelum" abbr="Cae" class="textConstellationLabel"></div> <div ra="1.571" dec="1.222" fullName="Camelopardalis" abbr="Cam" class="textConstellationLabel"></div> <div ra="2.251" dec="0.349" fullName="Cancer" abbr="Cnc" class="textConstellationLabel"></div> <div ra="3.403" dec="0.698" fullName="Canes Venatici" abbr="CVn" class="textConstellationLabel"></div> <div ra="1.754" dec="-0.384" fullName="Canis Major" abbr="CMa" class="textConstellationLabel"></div> <div ra="2.016" dec="0.098" fullName="Canis Minor" abbr="CMi" class="textConstellationLabel"></div> <div ra="5.498" dec="-0.349" fullName="Capricornus" abbr="Cap" class="textConstellationLabel"></div> <div ra="2.618" dec="-1.222" fullName="Carina" abbr="Car" class="textConstellationLabel"></div> <div ra="0.131" dec="1.047" fullName="Cassiopeia" abbr="Cas" class="textConstellationLabel"></div> <div ra="3.403" dec="-0.785" fullName="Centaurus" abbr="Cen" class="textConstellationLabel"></div> <div ra="5.890" dec="1.222" fullName="Cepheus" abbr="Cep" class="textConstellationLabel"></div> <div ra="0.393" dec="-0.209" fullName="Cetus" abbr="Cet" class="textConstellationLabel"></div> <div ra="2.775" dec="-1.361" fullName="Chamaeleon" abbr="Cha" class="textConstellationLabel"></div> <div ra="3.835" dec="-1.169" fullName="Circinus" abbr="Cir" class="textConstellationLabel"></div> <div ra="1.545" dec="-0.593" fullName="Columba" abbr="Col" class="textConstellationLabel"></div> <div ra="3.403" dec="0.407" fullName="Coma Berenices" abbr="Com" class="textConstellationLabel"></div> <div ra="4.843" dec="-0.716" fullName="Corona Austrina" abbr="CrA" class="textConstellationLabel"></div> <div ra="4.136" dec="0.559" fullName="Corona Borealis" abbr="CrB" class="textConstellationLabel"></div> <div ra="3.233" dec="-0.314" fullName="Corvus" abbr="Crv" class="textConstellationLabel"></div> <div ra="2.985" dec="-0.279" fullName="Crater" abbr="Crt" class="textConstellationLabel"></div> <div ra="3.272" dec="-1.047" fullName="Crux" abbr="Cru" class="textConstellationLabel"></div> <div ra="5.419" dec="0.733" fullName="Cygnus" abbr="Cyg" class="textConstellationLabel"></div> <div ra="5.406" dec="0.209" fullName="Delphinus" abbr="Del" class="textConstellationLabel"></div> <div ra="1.374" dec="-1.134" fullName="Dorado" abbr="Dor" class="textConstellationLabel"></div> <div ra="4.581" dec="1.134" fullName="Draco" abbr="Dra" class="textConstellationLabel"></div> <div ra="5.550" dec="0.148" fullName="Equuleus" abbr="Equ" class="textConstellationLabel"></div> <div ra="1.047" dec="-0.262" fullName="Eridanus" abbr="Eri" class="textConstellationLabel"></div> <div ra="0.720" dec="-0.559" fullName="Fornax" abbr="For" class="textConstellationLabel"></div> <div ra="1.833" dec="0.367" fullName="Gemini" abbr="Gem" class="textConstellationLabel"></div> <div ra="5.890" dec="-0.785" fullName="Grus" abbr="Gru" class="textConstellationLabel"></div> <div ra="4.581" dec="0.524" fullName="Hercules" abbr="Her" class="textConstellationLabel"></div> <div ra="0.864" dec="-0.873" fullName="Horologium" abbr="Hor" class="textConstellationLabel"></div> <div ra="2.618" dec="-0.349" fullName="Hydra" abbr="Hya" class="textConstellationLabel"></div> <div ra="0.600" dec="-1.344" fullName="Hydrus" abbr="Hyi" class="textConstellationLabel"></div> <div ra="5.616" dec="-0.960" fullName="Indus" abbr="Ind" class="textConstellationLabel"></div> <div ra="5.890" dec="0.785" fullName="Lacerta" abbr="Lac" class="textConstellationLabel"></div> <div ra="2.841" dec="0.262" fullName="Leo" abbr="Leo" class="textConstellationLabel"></div> <div ra="2.749" dec="0.576" fullName="Leo Minor" abbr="LMi" class="textConstellationLabel"></div> <div ra="1.440" dec="-0.349" fullName="Lepus" abbr="Lep" class="textConstellationLabel"></div> <div ra="4.058" dec="-0.175" fullName="Libra" abbr="Lib" class="textConstellationLabel"></div> <div ra="4.045" dec="-0.750" fullName="Lupus" abbr="Lup" class="textConstellationLabel"></div> <div ra="2.047" dec="0.873" fullName="Lynx" abbr="Lyn" class="textConstellationLabel"></div> <div ra="4.909" dec="0.663" fullName="Lyra" abbr="Lyr" class="textConstellationLabel"></div> <div ra="1.440" dec="-1.396" fullName="Mensa" abbr="Men" class="textConstellationLabel"></div> <div ra="5.498" dec="-0.663" fullName="Microscopium" abbr="Mic" class="textConstellationLabel"></div> <div ra="1.898" dec="-0.087" fullName="Monoceros" abbr="Mon" class="textConstellationLabel"></div> <div ra="3.272" dec="-1.222" fullName="Musca" abbr="Mus" class="textConstellationLabel"></div> <div ra="4.189" dec="-0.908" fullName="Norma" abbr="Nor" class="textConstellationLabel"></div> <div ra="0.000" dec="-1.571" fullName="Octans" abbr="Oct" class="textConstellationLabel"></div> <div ra="4.547" dec="-0.035" fullName="Ophiuchus" abbr="Oph" class="textConstellationLabel"></div> <div ra="1.492" dec="0.035" fullName="Orion" abbr="Ori" class="textConstellationLabel"></div> <div ra="5.157" dec="-1.187" fullName="Pavo" abbr="Pav" class="textConstellationLabel"></div> <div ra="5.956" dec="0.349" fullName="Pegasus" abbr="Peg" class="textConstellationLabel"></div> <div ra="0.890" dec="0.785" fullName="Perseus" abbr="Per" class="textConstellationLabel"></div> <div ra="0.065" dec="-0.873" fullName="Phoenix" abbr="Phe" class="textConstellationLabel"></div> <div ra="1.440" dec="-0.873" fullName="Pictor" abbr="Pic" class="textConstellationLabel"></div> <div ra="0.262" dec="0.209" fullName="Pisces" abbr="Psc" class="textConstellationLabel"></div> <div ra="5.890" dec="-0.524" fullName="Piscis Austrinus" abbr="PsA" class="textConstellationLabel"></div> <div ra="2.094" dec="-0.436" fullName="Puppis" abbr="Pup" class="textConstellationLabel"></div> <div ra="2.330" dec="-0.524" fullName="Pyxis" abbr="Pyx" class="textConstellationLabel"></div> <div ra="0.982" dec="-1.047" fullName="Reticulum" abbr="Ret" class="textConstellationLabel"></div> <div ra="5.157" dec="0.314" fullName="Sagitta" abbr="Sge" class="textConstellationLabel"></div> <div ra="4.974" dec="-0.489" fullName="Sagittarius" abbr="Sgr" class="textConstellationLabel"></div> <div ra="4.215" dec="-0.419" fullName="Scorpius" abbr="Sco" class="textConstellationLabel"></div> <div ra="0.079" dec="-0.559" fullName="Sculptor" abbr="Scl" class="textConstellationLabel"></div> <div ra="4.896" dec="-0.175" fullName="Scutum" abbr="Sct" class="textConstellationLabel"></div> <div ra="4.084" dec="0.209" fullName="Serpens Caput" abbr="Ser" class="textConstellationLabel"></div> <div ra="4.800" dec="-0.058" fullName="Serpens Cauda" abbr="Ser" class="textConstellationLabel"></div> <div ra="2.644" dec="-0.017" fullName="Sextans" abbr="Sex" class="textConstellationLabel"></div> <div ra="1.047" dec="0.262" fullName="Taurus" abbr="Tau" class="textConstellationLabel"></div> <div ra="5.040" dec="-0.908" fullName="Telescopium" abbr="Tel" class="textConstellationLabel"></div> <div ra="0.602" dec="0.576" fullName="Triangulum" abbr="Tri" class="textConstellationLabel"></div> <div ra="4.215" dec="-1.134" fullName="Triangulum Australe" abbr="TrA" class="textConstellationLabel"></div> <div ra="0.131" dec="-1.187" fullName="Tucana" abbr="Tuc" class="textConstellationLabel"></div> <div ra="2.880" dec="0.873" fullName="Ursa Major" abbr="UMa" class="textConstellationLabel"></div> <div ra="3.979" dec="1.333" fullName="Ursa Minor" abbr="UMi" class="textConstellationLabel"></div> <div ra="2.566" dec="-0.873" fullName="Vela" abbr="Vel" class="textConstellationLabel"></div> <div ra="3.534" dec="-0.099" fullName="Virgo" abbr="Vir" class="textConstellationLabel"></div> <div ra="2.094" dec="-1.222" fullName="Volans" abbr="Vol" class="textConstellationLabel"></div> <div ra="5.301" dec="0.454" fullName="Vulpecula" abbr="Vul" class="textConstellationLabel"></div> </div> </div> </div> </main> </body> </html>